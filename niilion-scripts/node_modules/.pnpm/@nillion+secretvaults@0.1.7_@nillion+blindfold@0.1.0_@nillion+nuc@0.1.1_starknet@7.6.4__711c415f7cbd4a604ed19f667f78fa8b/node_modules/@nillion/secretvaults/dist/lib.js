// src/builder.ts
import {
  InvocationBody,
  NilauthClient,
  NucTokenBuilder,
  PayerBuilder
} from "@nillion/nuc";

// src/common/cluster.ts
import { encrypt as encrypt2 } from "@nillion/blindfold";
import { isPlainObject } from "es-toolkit";

// src/common/blindfold.ts
import {
  allot,
  ClusterKey,
  encrypt,
  SecretKey,
  unify
} from "@nillion/blindfold";

// src/logger.ts
import pino from "pino";
import pinoPretty, { prettyFactory } from "pino-pretty";
var LOG_LEVEL_KEY = "NILLION_LOG_LEVEL";
var DEFAULT_LOG_LEVEL = "silent";
var VALID_LOG_LEVELS = [
  "fatal",
  "error",
  "warn",
  "info",
  "debug",
  "trace",
  "silent"
];
var safeStorage = {
  getItem: (key) => {
    try {
      return globalThis.localStorage?.getItem(key) ?? null;
    } catch {
      return null;
    }
  },
  setItem: (key, value) => {
    try {
      globalThis.localStorage?.setItem(key, value);
    } catch {
    }
  },
  removeItem: (key) => {
    try {
      globalThis.localStorage?.removeItem(key);
    } catch {
    }
  }
};
function isValidLogLevel(value) {
  return typeof value === "string" && VALID_LOG_LEVELS.includes(value);
}
function getInitialLogLevel() {
  let level = DEFAULT_LOG_LEVEL;
  const sources = [
    process.env?.[LOG_LEVEL_KEY],
    safeStorage.getItem(LOG_LEVEL_KEY),
    // @ts-ignore
    globalThis[LOG_LEVEL_KEY]
  ];
  for (const source of sources) {
    const levelAttempt = source?.toLowerCase();
    if (isValidLogLevel(levelAttempt)) {
      level = levelAttempt;
      break;
    }
  }
  return level;
}
function getLoggerForEnv() {
  const env = process.env.NODE_ENV ?? "production";
  const level = getInitialLogLevel();
  const isNode = typeof window === "undefined";
  if (env === "production" || !isNode) {
    return pino({
      level,
      browser: { asObject: true },
      base: null
    });
  }
  const stream = pinoPretty({
    colorize: true,
    levelFirst: true,
    translateTime: "SYS:h:MM:ss TT",
    ignore: "pid,hostname",
    sync: true
  });
  const hooks = {};
  if (env === "test") {
    hooks.streamWrite = (s) => {
      const prettify = prettyFactory({ sync: true, colorize: true });
      console.log(prettify(s));
      return s;
    };
  }
  return pino(
    {
      level,
      hooks
    },
    stream
  );
}
var Log = getLoggerForEnv();
function setLogLevel(level) {
  if (!isValidLogLevel(level)) {
    console.warn(`[Logger] Invalid log level: "${level}". Ignoring.`);
    return;
  }
  Log.level = level;
  safeStorage.setItem(LOG_LEVEL_KEY, level);
}
function getLogLevel() {
  return Log.level;
}
function clearStoredLogLevel() {
  safeStorage.removeItem(LOG_LEVEL_KEY);
}
if (typeof globalThis !== "undefined") {
  globalThis.__NILLION = {
    setLogLevel,
    getLogLevel,
    clearStoredLogLevel
  };
}

// src/common/blindfold.ts
async function toBlindfoldKey(options) {
  Log.debug(
    {
      hasExistingKey: "key" in options,
      operation: "operation" in options ? options.operation : "existing-key",
      clusterSize: options.clusterSize,
      useClusterKey: "useClusterKey" in options ? options.useClusterKey : false,
      hasSeed: "seed" in options && options.seed !== void 0
    },
    "Creating blindfold key"
  );
  if ("key" in options) {
    Log.debug({ keyType: options.key.constructor.name }, "Using existing key");
    return options.key;
  }
  const { operation, clusterSize } = options;
  const op = {
    [operation]: true
  };
  const threshold = "threshold" in options ? options.threshold : void 0;
  const cluster = { nodes: new Array(clusterSize).fill({}) };
  const useClusterKey = "useClusterKey" in options && options.useClusterKey;
  const useSeed = "seed" in options && options.seed !== void 0;
  const isClusterKey = useClusterKey || !useSeed && clusterSize > 1;
  const type = isClusterKey ? "ClusterKey" : "SecretKey";
  const key = isClusterKey ? await ClusterKey.generate(cluster, op, threshold) : await SecretKey.generate(
    cluster,
    op,
    threshold,
    "seed" in options ? options.seed : void 0
  );
  Log.debug(
    {
      key: type,
      operation,
      threshold,
      nodes: clusterSize
    },
    "Key generated"
  );
  return key;
}
async function reveal(key, shares) {
  const unified = await unify(key, shares);
  Log.debug(
    {
      type: key.constructor.name,
      keys: Object.keys(unified)
    },
    "Revealed data"
  );
  return unified;
}

// src/common/cluster.ts
async function executeOnCluster(nodes, operation) {
  Log.debug({ nodes: nodes.length }, "Executing cluster operation");
  const promises = nodes.map(async (client, index) => {
    const node = client.id.toString();
    Log.debug({ node, index }, "Starting node operation");
    try {
      const result = await operation(client, index);
      return [node, result];
    } catch (error) {
      throw [node, error];
    }
  });
  const results = await Promise.allSettled(promises);
  const successes = [];
  const failures = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      successes.push(result.value);
    } else {
      const [node, error] = result.reason;
      const cause = error.cause;
      const flattened = {
        message: error?.message ?? "",
        body: cause?.body ?? void 0,
        status: cause?.status ?? void 0
      };
      failures.push({
        node,
        error: flattened
      });
    }
  }
  if (failures.length > 0) {
    Log.error({ successes, failures }, "Cluster operation failed");
    throw failures;
  }
  Log.debug("Cluster operation succeeded");
  return Object.fromEntries(successes);
}
function findAllotPathsAndValues(node, currentPath = "") {
  if (Array.isArray(node)) {
    return node.flatMap((item, index) => {
      const fullPath = currentPath ? `${currentPath}.${index}` : `${index}`;
      if (isPlainObject(item)) {
        return findAllotPathsAndValues(
          item,
          fullPath
        );
      }
      return [];
    });
  }
  return Object.entries(node).flatMap(([key, value]) => {
    const fullPath = currentPath ? `${currentPath}.${key}` : key;
    if (key.toLowerCase() === "%allot") {
      return [{ path: fullPath, value }];
    }
    if (isPlainObject(value)) {
      return findAllotPathsAndValues(
        value,
        fullPath
      );
    }
    if (Array.isArray(value)) {
      return findAllotPathsAndValues(value, fullPath);
    }
    return [];
  });
}
async function prepareRequest(options) {
  const { key, clients, body } = options;
  const allots = findAllotPathsAndValues(body);
  if (!key && allots.length > 0) {
    throw new Error(`No key but ${allots.length} %allot(s) detected in data`);
  }
  const sharesMap = /* @__PURE__ */ new Map();
  if (key && allots.length > 0) {
    for (const { path, value } of allots) {
      const encryptedShares = await encrypt2(key, value);
      const sharesByNode = {};
      clients.forEach((client, index) => {
        sharesByNode[client.id.toString()] = encryptedShares[index];
      });
      sharesMap.set(path, sharesByNode);
    }
  }
  const result = {};
  clients.forEach((client) => {
    const bodyCopy = structuredClone(body);
    if (key && allots.length > 0) {
      for (const { path } of allots) {
        const sharesByNode = sharesMap.get(path);
        if (sharesByNode) {
          const pathParts = path.split(".");
          const allotKey = pathParts.pop();
          if (!allotKey) {
            throw new Error(
              `Expected an allot key in the path parts: ${pathParts}`
            );
          }
          if (pathParts.length === 0) {
            delete bodyCopy[allotKey];
            bodyCopy["%share"] = sharesByNode[client.id.toString()];
          } else {
            let parent = bodyCopy;
            for (const part of pathParts) {
              const index = Number(part);
              if (Number.isNaN(index)) {
                parent = parent[part];
              } else {
                parent = parent[index];
              }
            }
            delete parent[allotKey];
            parent["%share"] = sharesByNode[client.id.toString()];
          }
        }
      }
    }
    result[client.id.toString()] = bodyCopy;
  });
  return result;
}
function processPlaintextResponse(results, strategy = "first") {
  const values = Object.values(results);
  Log.debug(
    { nodes: values.length, strategy },
    "Processing plaintext response"
  );
  let index = 0;
  if (strategy === "random") {
    index = Math.floor(Math.random() * values.length);
  }
  const selected = values.at(index);
  if (selected === void 0) {
    Log.error({ resultsCount: values.length }, "No response to select");
    throw new Error("Failed to select a canonical response.", {
      cause: results
    });
  }
  Log.debug({ selectedIndex: index }, "Response selected");
  return selected;
}
async function processConcealedListResponse(options) {
  const { key, resultsByNode } = options;
  Log.debug(
    {
      key: key.constructor.name,
      nodes: Object.keys(resultsByNode).length
    },
    "Processing concealed list response"
  );
  const allShares = Object.values(resultsByNode).flatMap((r) => r.data);
  Log.debug({ totalShares: allShares.length }, "Flattened document shares");
  const groupedShares = allShares.reduce((acc, doc) => {
    const docId = doc._id;
    if (docId) {
      const group = acc.get(docId) ?? [];
      group.push(doc);
      acc.set(docId, group);
    }
    return acc;
  }, /* @__PURE__ */ new Map());
  Log.debug(
    { documentCount: groupedShares.size },
    "Grouped shares by document ID"
  );
  const revealPromises = Array.from(groupedShares.values()).map(
    (shares) => reveal(key, shares)
  );
  const revealed = await Promise.all(revealPromises);
  Log.debug(
    { revealedCount: revealed.length },
    "Documents revealed successfully"
  );
  return revealed;
}
async function processConcealedObjectResponse(options) {
  const { key, resultsByNode } = options;
  Log.debug(
    {
      key: key.constructor.name,
      nodes: Object.keys(resultsByNode).length
    },
    "Processing concealed object response"
  );
  const shares = Object.values(resultsByNode).map((response) => response.data);
  Log.debug({ shareCount: shares.length }, "Collected object shares");
  const revealed = await reveal(key, shares);
  Log.debug("Object revealed successfully");
  return revealed;
}

// src/base.ts
var SecretVaultBaseClient = class {
  _options;
  constructor(options) {
    this._options = options;
  }
  get id() {
    return this.did.toString();
  }
  /**
   * The DID of the keypair associated with this client.
   */
  get did() {
    return this._options.keypair.toDid();
  }
  /**
   * The array of underlying node clients for the cluster.
   */
  get nodes() {
    return this._options.clients;
  }
  /**
   * The keypair used by this client for signing.
   */
  get keypair() {
    return this._options.keypair;
  }
  /**
   * Retrieves information about each node in the cluster.
   */
  async readClusterInfo() {
    const result = await executeOnCluster(this.nodes, (c) => c.aboutNode());
    Log.info({ nodes: Object.keys(result).length }, "Cluster info retrieved");
    return result;
  }
};

// src/common/utils.ts
function intoSecondsFromNow(seconds) {
  return Math.floor((Date.now() + seconds * 1e3) / 1e3);
}
function pause(ms) {
  return new Promise((r) => setTimeout(r, ms));
}
function isError(value) {
  return value instanceof Error;
}

// src/common/nuc-cmd.ts
import { Command } from "@nillion/nuc";
function createNucNamespace(prefix) {
  const base = prefix.split("/");
  return {
    root: new Command([...base]),
    create: new Command([...base, "create"]),
    read: new Command([...base, "read"]),
    update: new Command([...base, "update"]),
    delete: new Command([...base, "delete"]),
    execute: new Command([...base, "execute"])
  };
}
var NucCmd = {
  nil: {
    db: {
      root: new Command(["nil", "db"]),
      system: createNucNamespace("nil/db/system"),
      builders: createNucNamespace("nil/db/builders"),
      data: createNucNamespace("nil/db/data"),
      collections: createNucNamespace("nil/db/collections"),
      queries: createNucNamespace("nil/db/queries"),
      users: createNucNamespace("nil/db/users")
    }
  }
};

// src/common/types.ts
import { z } from "zod";
var Uuid = z.uuid().brand();
var Did = z.string().startsWith("did:").superRefine((value, ctx) => {
  if (value.startsWith("did:ethr:")) {
    console.warn(
      "Received `did:ethr` which is not compatible with this version of secretvaults \u2014 upgrade to 1.0.0+."
    );
    return;
  }
  if (value.startsWith("did:nil:")) {
    return;
  }
  if (value.startsWith("did:key:")) {
    try {
      const multibaseKey = value.slice("did:key:".length);
      if (!multibaseKey || multibaseKey.length < 10) {
        ctx.addIssue({
          code: "custom",
          message: "Invalid did:key format - key portion too short"
        });
      }
    } catch {
      ctx.addIssue({
        code: "custom",
        message: "Invalid did:key format"
      });
    }
    return;
  }
  ctx.addIssue({
    code: "custom",
    message: `Unsupported DID method. Expected did:nil, did:key, or did:ethr, but got: ${value.slice(0, 10)}...`
  });
}).transform((value) => {
  if (value.startsWith("did:key:")) {
    return convertDidKeyToDidNil(value);
  }
  return value;
}).brand();
var BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function decodeBase58(str) {
  let num = 0n;
  for (let i = 0; i < str.length; i++) {
    const digit = BigInt(BASE58_ALPHABET.indexOf(str[i]));
    if (digit === -1n) {
      throw new Error(`Invalid base58 character: ${str[i]}`);
    }
    num = num * 58n + digit;
  }
  const bytes = [];
  while (num > 0n) {
    bytes.unshift(Number(num & 0xffn));
    num = num >> 8n;
  }
  for (let i = 0; i < str.length && str[i] === "1"; i++) {
    bytes.unshift(0);
  }
  return new Uint8Array(bytes.length > 0 ? bytes : [0]);
}
function convertDidKeyToDidNil(didKey) {
  try {
    const multibaseKey = didKey.slice("did:key:".length);
    if (!multibaseKey.startsWith("z")) {
      throw new Error("Expected multibase encoding type 'z' (base58)");
    }
    const decodedBytes = decodeBase58(multibaseKey.slice(1));
    const publicKeyHex = toHex(decodedBytes.slice(2));
    return `did:nil:${publicKeyHex}`;
  } catch (error) {
    throw new Error(
      `Failed to convert did:key to did:nil: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
function toHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

// src/nildb/builder-client.ts
import { z as z10 } from "zod";

// src/common/paths.ts
var NilDbEndpoint = {
  v1: {
    builders: {
      register: "/v1/builders/register",
      me: "/v1/builders/me"
    },
    data: {
      root: "/v1/data",
      find: "/v1/data/find",
      update: "/v1/data/update",
      delete: "/v1/data/delete",
      flushById: "/v1/data/:id/flush",
      tailById: "/v1/data/:id/tail",
      createOwned: "/v1/data/owned",
      createStandard: "/v1/data/standard"
    },
    queries: {
      root: "/v1/queries",
      byId: "/v1/queries/:id",
      run: "/v1/queries/run",
      runById: "/v1/queries/run/:id"
    },
    collections: {
      root: "/v1/collections",
      byId: "/v1/collections/:id",
      indexesById: "/v1/collections/:id/indexes",
      indexesByNameById: "/v1/collections/:id/indexes/:name"
    },
    system: {
      about: "/about",
      health: "/health",
      metrics: "/metrics",
      openApiJson: "/openapi.json",
      maintenanceStart: "/v1/system/maintenance/start",
      maintenanceStop: "/v1/system/maintenance/stop",
      logLevel: "/v1/system/log-level"
    },
    users: {
      me: "/v1/users/me",
      data: {
        root: "/v1/users/data",
        byId: "/v1/users/data/:collection/:document",
        aclById: "/v1/users/data/:collection/:document/acl",
        acl: {
          grant: "/v1/users/data/acl/grant",
          revoke: "/v1/users/data/acl/revoke"
        }
      }
    }
  }
};

// src/dto/builders.dto.ts
import { z as z3 } from "zod";

// src/dto/common.ts
import { z as z2 } from "zod";
var Name = z2.string().min(1).max(255);
var ApiSuccessResponse = (Schema) => z2.object({
  data: Schema
});
var ApiErrorResponse = z2.object({
  ts: z2.iso.datetime(),
  errors: z2.string().array()
});
var ByIdRequestParams = z2.object({
  id: z2.uuid()
});
var Acl = z2.object({
  grantee: Did,
  read: z2.boolean(),
  write: z2.boolean(),
  execute: z2.boolean()
});

// src/dto/builders.dto.ts
var RegisterBuilderRequest = z3.object({
  did: Did,
  name: Name
});
var RegisterBuilderResponse = z3.string();
var BuilderProfileDto = z3.object({
  _id: Did,
  _created: z3.iso.datetime(),
  _updated: z3.iso.datetime(),
  name: z3.string(),
  collections: z3.array(z3.uuid()),
  queries: z3.array(z3.uuid())
});
var ReadBuilderProfileResponse = ApiSuccessResponse(BuilderProfileDto);
var DeleteBuilderResponse = z3.string();
var UpdateBuilderProfileRequest = z3.object({
  name: Name
});
var UpdateBuilderProfileResponse = z3.string();

// src/dto/collections.dto.ts
import { z as z4 } from "zod";
var CollectionDocumentDto = z4.object({
  id: z4.uuid(),
  type: z4.enum(["standard", "owned"]),
  name: z4.string()
});
var CollectionDocuments = z4.array(CollectionDocumentDto);
var ListCollectionsResponse = ApiSuccessResponse(CollectionDocuments);
var CreateCollectionIndexRequest = z4.object({
  collection: z4.uuid(),
  name: z4.string().min(4),
  keys: z4.array(
    z4.record(z4.string(), z4.union([z4.literal(1), z4.literal(-1)])).refine(
      (obj) => Object.keys(obj).length === 1,
      "Each object must have exactly one key: [{ _id: 1 }, { foo: -1 }]"
    )
  ),
  unique: z4.boolean(),
  ttl: z4.number().optional()
});
var CreateCollectionIndexResponse = z4.string();
var DropCollectionIndexParams = z4.object({
  id: z4.uuid(),
  name: z4.string().min(4).max(50)
});
var DropCollectionIndexResponse = z4.string();
var CreateCollectionRequest = z4.object({
  _id: z4.uuid(),
  type: z4.union([z4.literal("standard"), z4.literal("owned")]),
  name: z4.string().min(1),
  schema: z4.record(z4.string(), z4.unknown())
});
var CreateCollectionResponse = z4.string();
var DeleteCollectionRequestParams = z4.object({
  id: z4.uuid()
});
var DeleteCollectionResponse = z4.string();
var ReadCollectionMetadataRequestParams = z4.object({
  id: z4.uuid()
});
var CollectionIndexDto = z4.object({
  v: z4.number(),
  key: z4.record(z4.string(), z4.union([z4.string(), z4.number()])),
  name: z4.string(),
  unique: z4.boolean()
});
var CollectionMetadataDto = z4.object({
  _id: z4.uuid(),
  count: z4.number(),
  size: z4.number(),
  first_write: z4.iso.datetime(),
  last_write: z4.iso.datetime(),
  indexes: z4.array(CollectionIndexDto),
  schema: z4.record(z4.string(), z4.unknown())
});
var ReadCollectionMetadataResponse = ApiSuccessResponse(
  CollectionMetadataDto
);

// src/dto/data.dto.ts
import { z as z6 } from "zod";

// src/dto/users.dto.ts
import { z as z5 } from "zod";
var AclDto = z5.object({
  grantee: Did,
  read: z5.boolean(),
  write: z5.boolean(),
  execute: z5.boolean()
});
var UserProfileData = z5.object({
  _id: Did,
  _created: z5.iso.datetime(),
  _updated: z5.iso.datetime(),
  logs: z5.array(
    z5.looseObject({
      op: z5.string(),
      collection: z5.uuid(),
      // present when op is "auth"
      acl: AclDto.optional()
    })
  ),
  data: z5.array(
    z5.object({
      collection: z5.uuid(),
      id: z5.uuid()
    })
  )
});
var ReadUserProfileResponse = ApiSuccessResponse(UserProfileData);
var ReadDataRequestParams = z5.object({
  collection: z5.uuid(),
  document: z5.uuid()
});
var OwnedDataDto = z5.looseObject({
  _id: z5.uuid(),
  _created: z5.iso.datetime(),
  _updated: z5.iso.datetime(),
  _owner: Did,
  _acl: z5.array(AclDto)
});
var ReadDataResponse = ApiSuccessResponse(OwnedDataDto);
var DataDocumentReference = z5.object({
  builder: Did,
  collection: z5.uuid(),
  document: z5.uuid()
});
var ListDataReferencesResponse = ApiSuccessResponse(
  z5.array(DataDocumentReference)
);
var ReadDataAclRequestParams = z5.object({
  collection: z5.uuid(),
  document: z5.uuid()
});
var ReadDataAccessResponse = ApiSuccessResponse(z5.array(AclDto));
var GrantAccessToDataRequest = z5.object({
  collection: z5.uuid(),
  document: z5.uuid(),
  acl: AclDto
});
var GrantAccessToDataResponse = z5.string();
var RevokeAccessToDataRequest = z5.object({
  grantee: Did,
  collection: z5.uuid(),
  document: z5.uuid()
});
var RevokeAccessToDataResponse = z5.string();
var DeleteDocumentRequestParams = z5.object({
  collection: z5.uuid(),
  document: z5.uuid()
});
var DeleteDocumentResponse = z5.string();
var UpdateUserDataRequest = z5.object({
  document: z5.uuid(),
  collection: z5.uuid(),
  update: z5.record(z5.string(), z5.unknown())
});

// src/dto/data.dto.ts
var CreateOwnedDataRequest = z6.object({
  owner: Did,
  collection: z6.uuid(),
  data: z6.array(z6.record(z6.string(), z6.unknown())).min(1),
  acl: AclDto
});
var CreateStandardDataRequest = z6.object({
  collection: z6.uuid(),
  data: z6.array(z6.record(z6.string(), z6.unknown())).min(1)
});
var CreateDataResponse = ApiSuccessResponse(
  z6.object({
    created: z6.array(z6.uuid()),
    errors: z6.array(
      z6.object({
        error: z6.string(),
        document: z6.unknown()
      })
    )
  })
);
var UpdateDataRequest = z6.object({
  collection: z6.uuid(),
  filter: z6.record(z6.string(), z6.unknown()),
  update: z6.record(z6.string(), z6.unknown())
});
var UpdateDataResponse = ApiSuccessResponse(
  z6.object({
    acknowledged: z6.boolean(),
    matched: z6.number().int().min(0),
    modified: z6.number().int().min(0),
    upserted: z6.number().int().min(0),
    upserted_id: z6.string().nullable()
  })
);
var FindDataRequest = z6.object({
  collection: z6.uuid(),
  filter: z6.record(z6.string(), z6.unknown())
});
var FindDataResponse = ApiSuccessResponse(
  z6.array(z6.record(z6.string(), z6.unknown()))
);
var DeleteDataRequest = z6.object({
  collection: z6.uuid(),
  filter: z6.record(z6.string(), z6.unknown()).refine((obj) => Object.keys(obj).length > 0, "Filter cannot be empty")
});
var DeleteDataResponse = ApiSuccessResponse(
  z6.object({
    acknowledged: z6.boolean(),
    deletedCount: z6.number().int().min(0)
  })
);
var FlushDataRequest = z6.object({
  collection: z6.uuid()
});
var FlushDataResponse = z6.string();
var DropDataResponse = ApiSuccessResponse(
  z6.object({
    acknowledged: z6.boolean(),
    deletedCount: z6.number().int().min(0)
  })
);
var DataSchemaByIdRequestParams = z6.object({
  id: z6.uuid()
});
var TailDataRequestParams = z6.object({
  id: z6.uuid()
});
var TailDataRequestQuery = z6.object({
  limit: z6.coerce.number().max(1e3).optional().default(25)
});
var TailDataResponse = ApiSuccessResponse(
  z6.array(z6.record(z6.string(), z6.unknown()))
);

// src/dto/queries.dto.ts
import { z as z7 } from "zod";
var PATH_EXPRESSION = /^\$(\.[$a-zA-Z][a-zA-Z0-9-_]+(\[\d+])*)+$/;
var VariablePath = z7.string().transform((path) => PATH_EXPRESSION.exec(path)).refine((match) => match !== null, "invalid PATH").transform((match) => match[0]);
var QueryVariableValidator = z7.object({
  path: VariablePath,
  description: z7.string().optional()
});
var CreateQueryRequest = z7.object({
  _id: z7.uuid(),
  name: z7.string().min(1).max(100),
  collection: z7.uuid(),
  variables: z7.record(z7.string(), QueryVariableValidator),
  pipeline: z7.array(z7.record(z7.string(), z7.unknown()))
});
var CreateQueryResponse = z7.string();
var QueryDocumentResponse = z7.object({
  _id: z7.uuid(),
  name: z7.string().min(1).max(100),
  collection: z7.uuid()
});
var ReadQueriesResponse = ApiSuccessResponse(
  z7.array(QueryDocumentResponse)
);
var ReadQueryResponse = ApiSuccessResponse(QueryDocumentResponse);
var DeleteQueryRequest = z7.object({
  id: z7.uuid()
});
var DeleteQueryResponse = z7.string();
var RunQueryRequest = z7.object({
  _id: z7.uuid(),
  variables: z7.record(z7.string(), z7.unknown())
});
var RunQueryResponse = ApiSuccessResponse(z7.uuid());
var RunQueryResultStatus = z7.enum([
  "pending",
  "running",
  "complete",
  "error"
]);
var ReadQueryRunByIdDto = z7.object({
  _id: z7.uuid(),
  query: z7.uuid(),
  status: RunQueryResultStatus,
  started: z7.iso.datetime().optional(),
  completed: z7.iso.datetime().optional(),
  result: z7.unknown().optional(),
  errors: z7.array(z7.string()).optional()
});
var ReadQueryRunByIdResponse = ApiSuccessResponse(ReadQueryRunByIdDto);

// src/nildb/base-client.ts
import { Did as NucDid } from "@nillion/nuc";
import { z as z9 } from "zod";

// src/dto/system.dto.ts
import { z as z8 } from "zod";
var ReadAboutNodeResponse = z8.object({
  started: z8.iso.datetime(),
  build: z8.object({
    time: z8.iso.datetime(),
    commit: z8.string(),
    version: z8.string()
  }),
  public_key: z8.string(),
  url: z8.string().url(),
  maintenance: z8.object({
    active: z8.boolean(),
    started_at: z8.iso.datetime()
  })
});
var NodeHealthCheckResponse = z8.literal("OK");

// src/nildb/base-client.ts
var NilDbBaseClientOptions = z9.object({
  about: ReadAboutNodeResponse,
  baseUrl: z9.string().min(15)
});
var NilDbBaseClient = class {
  #options;
  constructor(options) {
    this.#options = options;
  }
  get name() {
    return this.#options.about.public_key.slice(-4);
  }
  get id() {
    return NucDid.fromHex(this.#options.about.public_key);
  }
  /**
   * Handles error responses with consistent error information
   */
  handleErrorResponse(response, method, path, body) {
    throw new Error(`Request failed: ${method} ${path}`, {
      cause: {
        body,
        response,
        status: response.status,
        statusText: response.statusText
      }
    });
  }
  /**
   * Determines if an error is retryable based on its type
   */
  isRetryableError(error) {
    if (isError(error)) {
      const retryableNames = [
        "NetworkError",
        "AbortError",
        "TimeoutError",
        "ERR_NETWORK",
        "ECONNREFUSED",
        "ECONNRESET",
        "ETIMEDOUT",
        "ENOTFOUND",
        "EAI_AGAIN"
      ];
      if (retryableNames.includes(error.name)) {
        return true;
      }
      const message = error.message.toLowerCase();
      if (message.includes("network") || message.includes("fetch failed") || message.includes("connection refused") || message.includes("timeout")) {
        return true;
      }
      const cause = error.cause;
      if (cause?.status) {
        return cause.status >= 500 || cause.status === 429 || cause.status === 408;
      }
    }
    return false;
  }
  /**
   * Executes a fetch request with retry logic for network failures
   */
  async fetchWithRetry(endpoint, fetchOptions, context, maxRetries = 5) {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await fetch(endpoint, fetchOptions);
      } catch (error) {
        lastError = error;
        if (!this.isRetryableError(error) || attempt === maxRetries) {
          Log.debug(
            `${context} failed permanently after ${attempt} attempts: %O`,
            error
          );
          throw error;
        }
        const delay = Math.min(1e3 * 2 ** (attempt - 1), 1e4);
        Log.debug(
          `${context} failed (attempt ${attempt}/${maxRetries}), retrying in ${delay}ms: %O`,
          error
        );
        await pause(delay);
      }
    }
    throw lastError;
  }
  /**
   * Makes an authenticated request to the NilDb API
   */
  async request(options) {
    const { path, token, method = "GET", body, responseSchema } = options;
    const headers = {};
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }
    if (body) {
      headers["Content-Type"] = "application/json";
    }
    const endpoint = new URL(path, this.#options.baseUrl).toString();
    const context = `${method} ${path}`;
    const response = await this.fetchWithRetry(
      endpoint,
      {
        method,
        headers,
        ...body && { body: JSON.stringify(body) }
      },
      context
    );
    const contentType = response.headers.get("content-type") ?? "";
    const status = response.status;
    if (contentType.includes("application/json")) {
      const json = await response.json();
      Log.debug({ endpoint, json, status }, "Response was application/json");
      if (!response.ok) {
        this.handleErrorResponse(response, method, endpoint, json);
      }
      return responseSchema.parse(json);
    }
    if (contentType.includes("text/plain")) {
      const text = await response.text();
      Log.debug({ endpoint, text, status }, "Response was text/plain");
      if (!response.ok) {
        this.handleErrorResponse(response, method, path, text);
      }
      return responseSchema.parse(text);
    }
    Log.debug({ endpoint, status }, "Response had no body");
    if (!response.ok) {
      this.handleErrorResponse(response, method, path, null);
    }
    return responseSchema.parse(void 0);
  }
  /**
   * Retrieves comprehensive node information including version and configuration
   */
  async aboutNode() {
    return await this.request({
      path: NilDbEndpoint.v1.system.about,
      responseSchema: ReadAboutNodeResponse
    });
  }
  /**
   * Checks node health status
   */
  async healthCheck() {
    return await this.request({
      path: NilDbEndpoint.v1.system.health,
      responseSchema: NodeHealthCheckResponse
    });
  }
};

// src/nildb/builder-client.ts
var NilDbBuilderClientOptions = z10.object({
  ...NilDbBaseClientOptions.shape
});
var NilDbBuilderClient = class extends NilDbBaseClient {
  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: currently unused but useful to keep
  #options;
  constructor(options) {
    super(options);
    this.#options = options;
  }
  /**
   * Registers a new builder.
   */
  register(body) {
    return this.request({
      path: NilDbEndpoint.v1.builders.register,
      method: "POST",
      body,
      responseSchema: RegisterBuilderResponse
    });
  }
  /**
   * Retrieves the authenticated builder's profile information.
   */
  readProfile(token) {
    return this.request({
      path: NilDbEndpoint.v1.builders.me,
      token,
      responseSchema: ReadBuilderProfileResponse
    });
  }
  /**
   * Updates the authenticated builder's profile information.
   */
  updateProfile(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.builders.me,
      method: "POST",
      body,
      token,
      responseSchema: UpdateBuilderProfileResponse
    });
  }
  /**
   * Deletes the authenticated builder and all associated resources.
   */
  deleteBuilder(token) {
    return this.request({
      path: NilDbEndpoint.v1.builders.me,
      method: "DELETE",
      token,
      responseSchema: DeleteBuilderResponse
    });
  }
  /**
   * Creates a new collection for data validation.
   */
  createCollection(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.collections.root,
      method: "POST",
      body,
      token,
      responseSchema: CreateCollectionResponse
    });
  }
  /**
   * Lists all collections owned by the authenticated builder.
   */
  readCollections(token) {
    return this.request({
      path: NilDbEndpoint.v1.collections.root,
      method: "GET",
      token,
      responseSchema: ListCollectionsResponse
    });
  }
  /**
   * Deletes a collection by id and all associated data.
   */
  deleteCollection(token, collection) {
    return this.request({
      path: NilDbEndpoint.v1.collections.byId.replace(":id", collection),
      method: "DELETE",
      token,
      responseSchema: DeleteCollectionResponse
    });
  }
  /**
   * Retrieves a collection by id including metadata.
   */
  readCollection(token, collection) {
    return this.request({
      path: NilDbEndpoint.v1.collections.byId.replace(":id", collection),
      method: "GET",
      token,
      responseSchema: ReadCollectionMetadataResponse
    });
  }
  /**
   * Creates an index on a collection.
   */
  createCollectionIndex(token, collection, body) {
    return this.request({
      path: NilDbEndpoint.v1.collections.indexesById.replace(":id", collection),
      method: "POST",
      body,
      token,
      responseSchema: CreateCollectionIndexResponse
    });
  }
  /**
   * Drops an index from a collection.
   */
  dropCollectionIndex(token, collection, index) {
    return this.request({
      path: NilDbEndpoint.v1.collections.indexesByNameById.replace(":id", collection).replace(":name", index),
      method: "DELETE",
      token,
      responseSchema: DropCollectionIndexResponse
    });
  }
  /**
   * Lists all queries owned by the authenticated builder.
   */
  getQueries(token) {
    return this.request({
      path: NilDbEndpoint.v1.queries.root,
      token,
      responseSchema: ReadQueriesResponse
    });
  }
  /**
   * Retrieves a query by id.
   */
  getQuery(token, query) {
    return this.request({
      path: NilDbEndpoint.v1.queries.byId.replace(":id", query),
      token,
      responseSchema: ReadQueryResponse
    });
  }
  /**
   * Creates a new MongoDB aggregation query with variable substitution.
   */
  createQuery(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.queries.root,
      method: "POST",
      body,
      token,
      responseSchema: CreateQueryResponse
    });
  }
  /**
   * Deletes a query by id.
   */
  deleteQuery(token, query) {
    return this.request({
      path: NilDbEndpoint.v1.queries.byId.replace(":id", query),
      method: "DELETE",
      token,
      responseSchema: DeleteQueryResponse
    });
  }
  /**
   * Executes a query with variable substitution.
   */
  runQuery(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.queries.run,
      method: "POST",
      body,
      token,
      responseSchema: RunQueryResponse
    });
  }
  /**
   * Retrieves the status and results of a background query job.
   */
  readQueryRunResults(token, run) {
    return this.request({
      path: NilDbEndpoint.v1.queries.runById.replace(":id", run),
      token,
      responseSchema: ReadQueryRunByIdResponse
    });
  }
  /**
   * Uploads standard data records to a schema-validated collection.
   */
  createStandardData(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.data.createStandard,
      method: "POST",
      body,
      token,
      responseSchema: CreateDataResponse
    });
  }
  /**
   * Searches for data matching the provided filter.
   */
  findData(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.data.find,
      method: "POST",
      body,
      token,
      responseSchema: FindDataResponse
    });
  }
  /**
   * Updates data records matching the provided filter.
   */
  updateData(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.data.update,
      method: "POST",
      body,
      token,
      responseSchema: UpdateDataResponse
    });
  }
  /**
   * Deletes data records matching the provided filter.
   */
  deleteData(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.data.delete,
      method: "POST",
      body,
      token,
      responseSchema: DeleteDataResponse
    });
  }
  /**
   * Removes all data from a collection.
   */
  flushData(token, collection) {
    return this.request({
      path: NilDbEndpoint.v1.data.flushById.replace(":id", collection),
      method: "DELETE",
      token,
      responseSchema: FlushDataResponse
    });
  }
  /**
   * Retrieves the most recent data records from a collection.
   */
  tailData(token, collection, limit = 10) {
    return this.request({
      path: `${NilDbEndpoint.v1.data.tailById.replace(":id", collection)}?limit=${limit}`,
      method: "GET",
      token,
      responseSchema: TailDataResponse
    });
  }
};
async function createNilDbBuilderClient(baseUrl) {
  const response = await fetch(`${baseUrl}/about`);
  const body = await response.json();
  const validated = NilDbBuilderClientOptions.parse({
    about: body,
    baseUrl
  });
  return new NilDbBuilderClient(validated);
}

// src/builder.ts
var SecretVaultBuilderClient = class _SecretVaultBuilderClient extends SecretVaultBaseClient {
  /**
   * Creates and initializes a new SecretVaultBuilderClient instance.
   *
   * @param options - Configuration options for the client
   * @param options.keypair - The builder's keypair for authentication
   * @param options.urls - Nillion service URLs configuration from https://docs.nillion.com/build/network-config
   * @param options.urls.chain - URL of the nilChain URL
   * @param options.urls.auth - URL of the nilAuth authentication service
   * @param options.urls.dbs - URL Array of nilDB node endpoints
   * @param options.blindfold - Optional blindfold configuration for concealed data
   * @returns A promise that resolves to a configured SecretVaultBuilderClient
   *
   * @example
   * ```typescript
   * const client = await SecretVaultBuilderClient.from({
   *   keypair: myKeypair,
   *   urls: {
   *     chain: "http://rpc.testnet.nilchain-rpc-proxy.nilogy.xyz",
   *     auth: "https://nilauth.sandbox.app-cluster.sandbox.nilogy.xyz",
   *     dbs: ["https://nildb-stg-n1.nillion.network", "https://nildb-stg-n2.nillion.network", "https://nildb-stg-n3.nillion.network"]
   *   },
   *   blindfold: {
   *     // optional blindfold config
   *   }
   * });
   * ```
   */
  static async from(options) {
    const { urls, keypair, blindfold } = options;
    Log.debug(
      {
        did: keypair.toDid().toString(),
        dbCount: urls.dbs.length,
        blindfold: !!blindfold
      },
      "Creating SecretVaultBuilderClient"
    );
    const payerBuilder = await new PayerBuilder().keypair(keypair).chainUrl(urls.chain).build();
    const nilauthClient = await NilauthClient.from(urls.auth, payerBuilder);
    const clientPromises = urls.dbs.map(
      (base) => createNilDbBuilderClient(base)
    );
    const clients = await Promise.all(clientPromises);
    let client;
    if (blindfold) {
      if ("key" in blindfold) {
        client = new _SecretVaultBuilderClient({
          clients,
          keypair,
          key: blindfold.key,
          nilauthClient
        });
      } else {
        const key = await toBlindfoldKey({
          ...blindfold,
          clusterSize: clients.length
        });
        client = new _SecretVaultBuilderClient({
          clients,
          keypair,
          key,
          nilauthClient
        });
      }
    } else {
      client = new _SecretVaultBuilderClient({
        clients,
        keypair,
        nilauthClient
      });
    }
    Log.info(
      {
        id: keypair.toDid().toString().slice(-8),
        nodes: clients.length,
        encryption: client._options.key?.constructor.name ?? "none"
      },
      "SecretVaultBuilderClient created"
    );
    return client;
  }
  #rootToken = null;
  #nilauthClient;
  constructor(options) {
    super(options);
    this.#nilauthClient = options.nilauthClient;
  }
  get rootToken() {
    if (!this.#rootToken) {
      throw new Error("`refreshRootToken` must be called first");
    }
    return this.#rootToken;
  }
  /**
   * Fetches a new root NUC token from the configured nilAuth server.
   */
  async refreshRootToken() {
    Log.debug("Refreshing root token");
    const { token } = await this.#nilauthClient.requestToken(
      this._options.keypair,
      "nildb"
    );
    this.#rootToken = token;
    Log.info({ builder: this.id }, "Root token refreshed");
  }
  /**
   * Checks subscription status by the builder's Did.
   */
  subscriptionStatus() {
    return this.#nilauthClient.subscriptionStatus(
      this.keypair.publicKey("hex"),
      "nildb"
    );
  }
  /**
   * Registers the builder with all nodes in the cluster.
   */
  async register(body) {
    const result = await executeOnCluster(this.nodes, (c) => c.register(body));
    Log.info({ builder: this.id }, "Builder registered");
    return result;
  }
  /**
   * Reads the builder's profile from the cluster.
   */
  async readProfile() {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.builders.read
      });
      return client.readProfile(token);
    });
    const result = processPlaintextResponse(resultsByNode);
    Log.info({ builder: this.id }, "Builder profile read");
    return result;
  }
  /**
   * Updates the builder's profile on all nodes.
   */
  async updateBuilderProfile(body) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.builders.update
      });
      return client.updateProfile(token, body);
    });
    Log.info(
      { builder: this.id, updateFields: Object.keys(body) },
      "Builder profile updated"
    );
    return result;
  }
  /**
   * Deletes the builder and associated resources from all nodes.
   */
  async deleteBuilder() {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.builders.delete
      });
      return client.deleteBuilder(token);
    });
    Log.info({ builder: this.id }, "Builder deleted");
    return result;
  }
  /**
   * Creates a new collection on all nodes.
   */
  async createCollection(body) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.collections.create
      });
      return client.createCollection(token, body);
    });
    Log.info({ builder: this.id, collection: body.name }, "Collection created");
    return result;
  }
  /**
   * Reads a list of all collections from the cluster.
   */
  async readCollections() {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.collections.read
      });
      return client.readCollections(token);
    });
    const result = processPlaintextResponse(resultsByNode);
    Log.info(
      {
        builder: this.id,
        count: result.data?.length || 0
      },
      "Collections read"
    );
    return result;
  }
  /**
   * Reads the metadata for a single collection.
   */
  async readCollection(collection) {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.collections.read
      });
      return client.readCollection(token, collection);
    });
    const result = processPlaintextResponse(resultsByNode);
    Log.info({ builder: this.id, collection }, "Collection metadata read");
    return result;
  }
  /**
   * Deletes a collection its data from all nodes.
   */
  async deleteCollection(collection) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.collections.delete
      });
      return client.deleteCollection(token, collection);
    });
    Log.info({ builder: this.id, collection }, "Collection deleted");
    return result;
  }
  /**
   * Creates a new index on a collection.
   */
  async createCollectionIndex(collection, body) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.collections.update
      });
      return client.createCollectionIndex(token, collection, body);
    });
    Log.info(
      {
        builder: this.id,
        collection,
        name: body.name
      },
      "Collection index created"
    );
    return result;
  }
  /**
   * Drops an index from a collection.
   */
  async dropCollectionIndex(collection, index) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.collections.update
      });
      return client.dropCollectionIndex(token, collection, index);
    });
    Log.info(
      {
        builder: this.id,
        collection,
        index
      },
      "Collection index dropped"
    );
    return result;
  }
  /**
   * Creates one or more standard data documents in a collection.
   */
  async createStandardData(options) {
    const { body, delegation } = options;
    const { key, clients } = this._options;
    const nodePayloads = await prepareRequest({ key, clients, body });
    const result = await executeOnCluster(this.nodes, (client) => {
      let token = delegation;
      if (!token) {
        token = this.mintRootInvocation({
          audience: client.id,
          command: NucCmd.nil.db.data.create
        });
      }
      const id = Did.parse(client.id.toString());
      const payload = nodePayloads[id];
      return client.createStandardData(token, payload);
    });
    Log.info(
      {
        collection: body.collection,
        count: body.data.length,
        builder: this.id,
        isConcealed: !!key
      },
      "Data created"
    );
    return result;
  }
  /**
   * Retrieves a list of all saved queries.
   */
  async getQueries() {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.queries.read
      });
      return client.getQueries(token);
    });
    Log.info({ builder: this.id }, "Queries read");
    return result;
  }
  /**
   * Retrieves a single saved query by its id.
   */
  async getQuery(query) {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.queries.read
      });
      return client.getQuery(token, query);
    });
    Log.info({ query, builder: this.id }, "Query read");
    return result;
  }
  /**
   * Creates a new saved query on all nodes.
   */
  async createQuery(body) {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.queries.create
      });
      return client.createQuery(token, body);
    });
    Log.info(
      {
        builder: this.id,
        name: body.name,
        id: body._id,
        collection: body.collection
      },
      "Created query"
    );
    return result;
  }
  /**
   * Deletes a saved query from all nodes.
   */
  async deleteQuery(query) {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.queries.delete
      });
      return client.deleteQuery(token, query);
    });
    Log.info({ builder: this.id, query }, "Query deleted");
    return result;
  }
  /**
   * Starts a query execution job.
   */
  async runQuery(body) {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.queries.execute
      });
      return client.runQuery(token, body);
    });
    Log.info(
      {
        builder: this.id,
        query: body._id,
        run: Object.values(result)[0]?.data
      },
      "Started query run"
    );
    return result;
  }
  /**
   * Reads the results of a completed query run from each node.
   */
  readQueryRunResults(runs) {
    return executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.queries.read
      });
      const id = Did.parse(client.id.toString());
      const run = runs[id];
      return client.readQueryRunResults(token, run);
    });
  }
  /**
   * Finds data in a collection, revealing concealed values if a key is configured.
   */
  async findData(body) {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.data.read
      });
      return client.findData(token, body);
    });
    const { key } = this._options;
    let result;
    if (key) {
      const data = await processConcealedListResponse({ key, resultsByNode });
      result = { data };
    } else {
      result = processPlaintextResponse(resultsByNode);
    }
    Log.info(
      {
        builder: this.id,
        collection: body.collection,
        count: result.data?.length || 0
      },
      "Data found"
    );
    return result;
  }
  /**
   * Updates documents in a collection, concealing the update payload if a key is configured.
   */
  async updateData(body) {
    const { key, clients } = this._options;
    const nodePayloads = await prepareRequest({ key, clients, body });
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.data.update
      });
      const id = client.id.toString();
      return client.updateData(token, nodePayloads[id]);
    });
    Log.info(
      {
        builder: this.id,
        collection: body.collection,
        filter: body.filter
      },
      "Data updated"
    );
    return result;
  }
  /**
   * Deletes data from a collection based on a filter.
   */
  async deleteData(body) {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.data.delete
      });
      return client.deleteData(token, body);
    });
    Log.info(
      {
        builder: this.id,
        collection: body.collection,
        filter: body.filter
      },
      "Data deleted"
    );
    return result;
  }
  /**
   * Deletes all data from a collection.
   */
  async flushData(collection) {
    const result = await executeOnCluster(this.nodes, async (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.data.delete
      });
      return client.flushData(token, collection);
    });
    Log.info({ collection }, "Flushed data");
    return result;
  }
  /**
   * Reads the last N documents from a collection, revealing concealed values if a key is configured.
   */
  async tailData(collection, limit = 10) {
    Log.debug({ collection, limit }, "Tailing data");
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintRootInvocation({
        audience: client.id,
        command: NucCmd.nil.db.data.read
      });
      return client.tailData(token, collection, limit);
    });
    const { key } = this._options;
    let result;
    if (key) {
      const data = await processConcealedListResponse({ key, resultsByNode });
      result = { data };
    } else {
      result = processPlaintextResponse(resultsByNode);
    }
    Log.info({ collection, count: result.data?.length || 0 }, "Data tailed");
    return result;
  }
  mintRootInvocation(options) {
    return NucTokenBuilder.extending(this.rootToken).command(options.command).body(new InvocationBody({})).expiresAt(intoSecondsFromNow(60)).audience(options.audience).build(this.keypair.privateKey());
  }
};

// src/user.ts
import {
  InvocationBody as InvocationBody2,
  NucTokenBuilder as NucTokenBuilder2,
  NucTokenEnvelopeSchema
} from "@nillion/nuc";

// src/nildb/user-client.ts
import { z as z11 } from "zod";
var NilDbUserClientOptions = z11.object({
  ...NilDbBaseClientOptions.shape
});
var NilDbUserClient = class extends NilDbBaseClient {
  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: currently unused but useful to keep
  #options;
  constructor(options) {
    super(options);
    this.#options = options;
  }
  /**
   * Retrieves the authenticated user's profile information.
   */
  readProfile(token) {
    return this.request({
      path: NilDbEndpoint.v1.users.me,
      token,
      responseSchema: ReadUserProfileResponse
    });
  }
  /**
   * Lists all data records owned by the authenticated user.
   */
  listDataReferences(token) {
    return this.request({
      path: NilDbEndpoint.v1.users.data.root,
      token,
      responseSchema: ListDataReferencesResponse
    });
  }
  /**
   * Create user-owned data in an owned collection
   */
  createOwnedData(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.data.createOwned,
      method: "POST",
      token,
      body,
      responseSchema: CreateDataResponse
    });
  }
  /**
   * Retrieves user-owned data by collection and document id.
   */
  readData(token, params) {
    return this.request({
      path: NilDbEndpoint.v1.users.data.byId.replace(":collection", params.collection).replace(":document", params.document),
      token,
      responseSchema: ReadDataResponse
    });
  }
  /**
   * Deletes a user-owned data document.
   */
  deleteData(token, params) {
    return this.request({
      path: NilDbEndpoint.v1.users.data.byId.replace(":collection", params.collection).replace(":document", params.document),
      method: "DELETE",
      token,
      responseSchema: DeleteDocumentResponse
    });
  }
  /**
   * Grants access to user-owned data.
   */
  grantAccess(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.users.data.acl.grant,
      method: "POST",
      body,
      token,
      responseSchema: GrantAccessToDataResponse
    });
  }
  /**
   * Removes access to user-owned data.
   */
  revokeAccess(token, body) {
    return this.request({
      path: NilDbEndpoint.v1.users.data.acl.revoke,
      method: "POST",
      body,
      token,
      responseSchema: RevokeAccessToDataResponse
    });
  }
};
async function createNilDbUserClient(baseUrl) {
  const response = await fetch(`${baseUrl}/about`);
  const about = await response.json();
  const validated = NilDbUserClientOptions.parse({
    about,
    baseUrl
  });
  return new NilDbUserClient(validated);
}

// src/user.ts
var SecretVaultUserClient = class _SecretVaultUserClient extends SecretVaultBaseClient {
  /**
   * Creates and initializes a new SecretVaultUserClient instance.
   *
   * @param options - Configuration options for the client
   * @param options.keypair - The user's keypair for authentication
   * @param options.baseUrls - URL Array of nilDB node endpoints
   * @param options.blindfold - Optional blindfold configuration for concealed data
   * @returns A promise that resolves to a configured SecretVaultUserClient
   *
   * @example
   * ```typescript
   * const client = await SecretVaultUserClient.from({
   *   keypair: myKeypair,
   *   baseUrls: [
   *     'https://nildb-stg-n1.nillion.network',
   *     'https://nildb-stg-n2.nillion.network',
   *     'https://nildb-stg-n3.nillion.network',
   *   ],
   * });
   * ```
   */
  static async from(options) {
    const { baseUrls, keypair, blindfold } = options;
    const clientPromises = baseUrls.map((u) => createNilDbUserClient(u));
    const clients = await Promise.all(clientPromises);
    let client;
    if (blindfold) {
      if ("key" in blindfold) {
        client = new _SecretVaultUserClient({
          clients,
          keypair,
          key: blindfold.key
        });
      } else {
        const key = await toBlindfoldKey({
          ...blindfold,
          clusterSize: clients.length
        });
        client = new _SecretVaultUserClient({
          clients,
          keypair,
          key
        });
      }
    } else {
      client = new _SecretVaultUserClient({
        clients,
        keypair
      });
    }
    Log.info(
      {
        did: keypair.toDid().toString(),
        nodes: clients.length,
        encryption: client._options.key?.constructor.name ?? "none"
      },
      "SecretVaultUserClient created"
    );
    return client;
  }
  /**
   * Reads the user's profile information from the cluster.
   */
  async readProfile() {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintInvocation({
        command: NucCmd.nil.db.users.root,
        audience: client.id
      });
      return client.readProfile(token);
    });
    const result = processPlaintextResponse(resultsByNode);
    Log.info({ user: this.id }, "User profile read");
    return result;
  }
  /**
   * Creates one or more data documents owned by the user.
   */
  async createData(delegation, body) {
    const { key, clients } = this._options;
    const nodePayloads = await prepareRequest({ key, clients, body });
    const result = await executeOnCluster(this.nodes, (client) => {
      const envelop = NucTokenEnvelopeSchema.parse(delegation);
      const token = NucTokenBuilder2.extending(envelop).audience(client.id).command(NucCmd.nil.db.data.create).expiresAt(intoSecondsFromNow(60)).body(new InvocationBody2({})).build(this.keypair.privateKey());
      const id = Did.parse(client.id.toString());
      const payload = nodePayloads[id];
      return client.createOwnedData(token, payload);
    });
    Log.info(
      {
        user: this.id,
        collection: body.collection,
        documents: body.data.length,
        concealed: !!key
      },
      "User data created"
    );
    return result;
  }
  /**
   * Lists references to all data documents owned by the user.
   */
  async listDataReferences() {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintInvocation({
        command: NucCmd.nil.db.users.read,
        audience: client.id
      });
      return client.listDataReferences(token);
    });
    const result = processPlaintextResponse(resultsByNode);
    Log.info(
      { user: this.id, count: result.data?.length || 0 },
      "User data references listed"
    );
    return result;
  }
  /**
   * Reads a single data document, automatically revealing concealed values if a key is configured.
   */
  async readData(params) {
    const resultsByNode = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintInvocation({
        command: NucCmd.nil.db.users.read,
        audience: client.id
      });
      return client.readData(token, params);
    });
    const { key } = this._options;
    let result;
    if (key) {
      const data = await processConcealedObjectResponse({
        key,
        resultsByNode
      });
      result = { data };
    } else {
      result = processPlaintextResponse(resultsByNode);
    }
    Log.info(
      {
        user: this.id,
        collection: params.collection,
        document: params.document
      },
      "User data read"
    );
    return result;
  }
  /**
   * Deletes a user-owned document from all nodes.
   */
  async deleteData(params) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintInvocation({
        command: NucCmd.nil.db.users.delete,
        audience: client.id
      });
      return client.deleteData(token, params);
    });
    Log.info(
      {
        user: this.id,
        collection: params.collection,
        document: params.document
      },
      "User data deleted"
    );
    return result;
  }
  /**
   * Grants a given Did access to a given user-owned document.
   */
  async grantAccess(body) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintInvocation({
        command: NucCmd.nil.db.users.update,
        audience: client.id
      });
      return client.grantAccess(token, body);
    });
    Log.info(
      {
        user: this.id,
        collection: body.collection,
        document: body.document,
        grantee: body.acl.grantee
      },
      "Data access granted"
    );
    return result;
  }
  /**
   * Revokes access for a given Did to the specified user-owned document.
   */
  async revokeAccess(body) {
    const result = await executeOnCluster(this.nodes, (client) => {
      const token = this.mintInvocation({
        command: NucCmd.nil.db.users.update,
        audience: client.id
      });
      return client.revokeAccess(token, body);
    });
    Log.info(
      {
        user: this.id,
        collection: body.collection,
        document: body.document,
        revokee: body.grantee
      },
      "Data access revoked"
    );
    return result;
  }
  mintInvocation(options) {
    const builder = NucTokenBuilder2.invocation({});
    return builder.command(options.command).subject(this.did).audience(options.audience).expiresAt(intoSecondsFromNow(60)).build(this.keypair.privateKey());
  }
};
export {
  Acl,
  AclDto,
  ApiErrorResponse,
  ApiSuccessResponse,
  ByIdRequestParams,
  CollectionDocumentDto,
  CollectionDocuments,
  CollectionIndexDto,
  CollectionMetadataDto,
  CreateCollectionIndexRequest,
  CreateCollectionIndexResponse,
  CreateCollectionRequest,
  CreateCollectionResponse,
  CreateDataResponse,
  CreateOwnedDataRequest,
  CreateQueryRequest,
  CreateQueryResponse,
  CreateStandardDataRequest,
  DataSchemaByIdRequestParams,
  DeleteBuilderResponse,
  DeleteCollectionRequestParams,
  DeleteCollectionResponse,
  DeleteDataRequest,
  DeleteDataResponse,
  DeleteDocumentRequestParams,
  DeleteDocumentResponse,
  DeleteQueryRequest,
  DeleteQueryResponse,
  Did,
  DropCollectionIndexParams,
  DropCollectionIndexResponse,
  DropDataResponse,
  FindDataRequest,
  FindDataResponse,
  FlushDataRequest,
  FlushDataResponse,
  GrantAccessToDataRequest,
  GrantAccessToDataResponse,
  ListCollectionsResponse,
  ListDataReferencesResponse,
  Name,
  NodeHealthCheckResponse,
  NucCmd,
  QueryVariableValidator,
  ReadAboutNodeResponse,
  ReadBuilderProfileResponse,
  ReadCollectionMetadataRequestParams,
  ReadCollectionMetadataResponse,
  ReadDataAccessResponse,
  ReadDataAclRequestParams,
  ReadDataRequestParams,
  ReadDataResponse,
  ReadQueriesResponse,
  ReadQueryResponse,
  ReadQueryRunByIdResponse,
  ReadUserProfileResponse,
  RegisterBuilderRequest,
  RegisterBuilderResponse,
  RevokeAccessToDataRequest,
  RevokeAccessToDataResponse,
  RunQueryRequest,
  RunQueryResponse,
  RunQueryResultStatus,
  SecretVaultBuilderClient,
  SecretVaultUserClient,
  TailDataRequestParams,
  TailDataRequestQuery,
  TailDataResponse,
  UpdateBuilderProfileRequest,
  UpdateBuilderProfileResponse,
  UpdateDataRequest,
  UpdateDataResponse,
  UpdateUserDataRequest,
  Uuid
};
//# sourceMappingURL=lib.js.map